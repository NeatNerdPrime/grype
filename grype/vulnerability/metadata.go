package vulnerability

import (
	"math"
	"strings"
	"time"
)

type Metadata struct {
	ID             string
	DataSource     string
	Namespace      string
	Severity       string
	URLs           []string
	Description    string
	Cvss           []Cvss
	KnownExploited []KnownExploited
	EPSS           []EPSS
}

func (m Metadata) ThreatScore() float64 {
	// if KEV data exists, boost towards the top.
	if len(m.KnownExploited) > 0 {
		return 1
	}

	epss := getEPSS(m.EPSS)
	severity := getNormalizedSeverity(m.Severity, m.Cvss)

	if severity == 0 {
		return epss
	}

	if epss == 0 {
		return severity
	}

	// use geometric mean to combine the two scores since we're dealing with ratio-like elements.
	return geometricMean(severity, epss)
}

type Cvss struct {
	Source         string
	Type           string
	Version        string
	Vector         string
	Metrics        CvssMetrics
	VendorMetadata interface{}
}

type CvssMetrics struct {
	BaseScore           float64
	ExploitabilityScore *float64
	ImpactScore         *float64
}

type KnownExploited struct {
	CVE                        string
	VendorProject              string
	Product                    string
	DateAdded                  *time.Time
	RequiredAction             string
	DueDate                    *time.Time
	KnownRansomwareCampaignUse string
	Notes                      string
	URLs                       []string
	CWEs                       []string
}

type EPSS struct {
	CVE        string
	EPSS       float64
	Percentile float64
	Date       time.Time
}

func getEPSS(epss []EPSS) float64 {
	var ps []float64
	for _, e := range epss {
		ps = append(ps, e.Percentile)
	}
	return geometricMean(ps...)
}

func geometricMean(numbers ...float64) float64 {
	if len(numbers) == 0 {
		return 0
	}
	var sumLog float64
	for _, num := range numbers {
		sumLog += math.Log(num)
	}

	return math.Exp(sumLog / float64(len(numbers)))
}

func getNormalizedSeverity(severity string, cvss []Cvss) float64 {
	// normalize CVSS base score to a 0-1 scale
	return getCvssBaseScore(severity, cvss) / 10.0
}

func getCvssBaseScore(severity string, cvss []Cvss) float64 {
	highest := 0.0
	for _, c := range onlyPrimaryCVSSIfExists(cvss) {
		if c.Metrics.BaseScore > highest {
			highest = c.Metrics.BaseScore
		}
	}

	if severity != "" && highest == 0 {
		// pseudo cvss scoring as a fallback
		switch strings.ToLower(severity) {
		case "negligible":
			return 0.1
		case "low":
			return 1
		case "medium":
			return 4
		case "high":
			return 7
		case "critical":
			return 9
		}
	}

	return highest
}

func onlyPrimaryCVSSIfExists(cvss []Cvss) []Cvss {
	var primary []Cvss
	for _, c := range cvss {
		if c.Type == "Primary" {
			primary = append(primary, c)
		}
	}

	if len(primary) == 0 {
		return cvss
	}
	return primary
}
