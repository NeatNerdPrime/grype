// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: affected_packages.sql

package repository

import (
	"context"
	"database/sql"
)

const createAffectedPackage = `-- name: CreateAffectedPackage :one
INSERT INTO affected_packages (vulnerability_id, ecosystem, package_name, purl)
VALUES (?, ?, ?, ?)
RETURNING affected_id
`

type CreateAffectedPackageParams struct {
	VulnerabilityID sql.NullInt64  `db:"vulnerability_id" json:"vulnerabilityId"`
	Ecosystem       sql.NullString `db:"ecosystem" json:"ecosystem"`
	PackageName     sql.NullString `db:"package_name" json:"packageName"`
	Purl            sql.NullString `db:"purl" json:"purl"`
}

func (q *Queries) CreateAffectedPackage(ctx context.Context, arg CreateAffectedPackageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAffectedPackage,
		arg.VulnerabilityID,
		arg.Ecosystem,
		arg.PackageName,
		arg.Purl,
	)
	var affected_id int64
	err := row.Scan(&affected_id)
	return affected_id, err
}

const listAffectedPackagesByPackageName = `-- name: ListAffectedPackagesByPackageName :many
SELECT affected_id, vulnerability_id, ecosystem, package_name, purl FROM affected_packages
WHERE package_name = ?
`

func (q *Queries) ListAffectedPackagesByPackageName(ctx context.Context, packageName sql.NullString) ([]AffectedPackage, error) {
	rows, err := q.db.QueryContext(ctx, listAffectedPackagesByPackageName, packageName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AffectedPackage{}
	for rows.Next() {
		var i AffectedPackage
		if err := rows.Scan(
			&i.AffectedID,
			&i.VulnerabilityID,
			&i.Ecosystem,
			&i.PackageName,
			&i.Purl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAffectedPackagesByPackageNameAndEcosystem = `-- name: ListAffectedPackagesByPackageNameAndEcosystem :many
SELECT affected_id, vulnerability_id, ecosystem, package_name, purl FROM affected_packages
WHERE package_name = ?
  AND ecosystem = ?
ORDER BY package_name, ecosystem
`

type ListAffectedPackagesByPackageNameAndEcosystemParams struct {
	PackageName sql.NullString `db:"package_name" json:"packageName"`
	Ecosystem   sql.NullString `db:"ecosystem" json:"ecosystem"`
}

func (q *Queries) ListAffectedPackagesByPackageNameAndEcosystem(ctx context.Context, arg ListAffectedPackagesByPackageNameAndEcosystemParams) ([]AffectedPackage, error) {
	rows, err := q.db.QueryContext(ctx, listAffectedPackagesByPackageNameAndEcosystem, arg.PackageName, arg.Ecosystem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AffectedPackage{}
	for rows.Next() {
		var i AffectedPackage
		if err := rows.Scan(
			&i.AffectedID,
			&i.VulnerabilityID,
			&i.Ecosystem,
			&i.PackageName,
			&i.Purl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
