package v6

import (
	"github.com/anchore/grype/internal/log"
)

type VulnerabilityStore interface {
	AddVulnerabilities(vulns ...*Vulnerability) error
	GetVulnerability(vulnID string, includeAffectedPkgs bool) ([]Vulnerability, error)
}

type vulnerabilityStore struct {
	*StoreConfig
	*state
}

func NewVulnerabilityStore(cfg *StoreConfig) VulnerabilityStore {
	return &vulnerabilityStore{
		StoreConfig: cfg,
		state:       cfg.state(),
	}
}

func (s *vulnerabilityStore) GetVulnerability(id string, loadAuxInfo bool) ([]Vulnerability, error) {
	log.WithFields("name", id).Trace("fetching Vulnerability record")

	var models []Vulnerability

	db := s.db
	if loadAuxInfo {
		fields := s.getPreloadableFields(&Vulnerability{})
		for _, field := range fields {
			db = db.Preload(field)
		}
	}

	result := db.Where("name = ?", id).Find(&models)
	return models, result.Error
}

func (s *vulnerabilityStore) AddVulnerabilities(vulnerabilities ...*Vulnerability) error {
	for _, h := range []func([]*Vulnerability) error{
		//s.handleOSs,
		//s.handleRangeEvents,
		//s.handleCPEs,
		//s.handlePackages,
	} {
		if err := h(vulnerabilities); err != nil {
			return err
		}

	}

	for _, v := range vulnerabilities {
		if err := s.db.Create(v).Error; err != nil {
			return err
		}

	}
	return nil
}

//func (s *vulnerabilityStore) handlePackages(vulns []*Vulnerability) error {
//	// ensure unique packages
//	unique, err := ensureUniquePackages(s.db, vulns)
//	if err != nil {
//		return err
//	}
//
//	// update vulnerabilities with package IDs
//	updateAffectedsWithPackages(vulns, unique)
//
//	return nil
//}
//
//func ensureUniquePackages(db *gorm.DB, vulns []*Vulnerability) ([]*Package, error) {
//	// map to track unique packages
//	pkgMap := make(map[string]*Package)
//	for _, v := range vulns {
//		for _, a := range *v.Affected {
//			if a.Packages == nil {
//				continue
//			}
//			pkgs := *a.Packages
//			for i, p := range pkgs {
//				pkgKey := fmt.Sprintf("%s:%s", strVal(p.Ecosystem), p.PackageName)
//				val := &pkgs[i]
//				pkgMap[pkgKey] = val
//			}
//		}
//	}
//
//	// extract unique packages
//	var uniquePackages []*Package
//	for _, pkg := range pkgMap {
//		uniquePackages = append(uniquePackages, pkg)
//	}
//
//	// insert unique packages into the database or fetch existing ones
//	for i, pkg := range uniquePackages {
//		var existing Package
//		err := db.Where("package_name = ? AND ecosystem = ?", pkg.Name, pkg.Ecosystem).
//			FirstOrCreate(&existing, pkg).Error
//		if err != nil {
//			return nil, err
//		}
//		uniquePackages[i].ID = existing.ID
//	}
//
//	return uniquePackages, nil
//
//}
//
//func updateAffectedsWithPackages(vulns []*Vulnerability, uniquePackages []*Package) {
//	pkgMap := make(map[string]int64)
//	for _, p := range uniquePackages {
//		pkgKey := fmt.Sprintf("%s:%s", strVal(p.Ecosystem), p.Name)
//		pkgMap[pkgKey] = p.ID
//	}
//
//	for i, v := range vulns {
//		for j, a := range *v.Affected {
//			if a.Packages == nil {
//				continue
//			}
//			pkgs := *a.Packages
//			for k, p := range pkgs {
//				pkgKey := fmt.Sprintf("%s:%s", strVal(p.Ecosystem), p.PackageName)
//				val := pkgMap[pkgKey]
//				(*(*vulns[i].Affected)[j].Packages)[k].ID = val
//			}
//		}
//	}
//
//}

//func (s *vulnerabilityStore) handleCPEs(vulns []*Vulnerability) error {
//	// ensure unique cpes
//	unique, err := ensureUniqueCPEs(s.db, vulns)
//	if err != nil {
//		return err
//	}
//
//	// update vulnerabilities with cpes IDs
//	updateAffectedsWithCPEs(vulns, unique)
//
//	return nil
//}
//
//func updateAffectedsWithCPEs(vulns []*Vulnerability, uniqueCPEs []*Cpes) {
//	cpeMap := make(map[string]int64)
//	for _, c := range uniqueCPEs {
//		cpeKey := c.String()
//		cpeMap[cpeKey] = c.ID
//	}
//
//	for i, v := range vulns {
//		if v.Affected == nil {
//			continue
//		}
//		for j, a := range *v.Affected {
//			if a.Cpes != nil {
//				cpeKey := a.Cpes.String()
//				val := cpeMap[cpeKey]
//				(*(*vulns[i].Affected)[j].Cpes).ID = val
//			}
//			if a.PlatformCpes != nil {
//				cpeKey := a.PlatformCpes.String()
//				val := cpeMap[cpeKey]
//				(*(*vulns[i].Affected)[j].PlatformCpes).ID = val
//			}
//		}
//	}
//}
//
//func ensureUniqueCPEs(db *gorm.DB, vulns []*Vulnerability) ([]*Cpes, error) {
//	cpeMap := make(map[string]Cpes)
//	for _, v := range vulns {
//		if v.Affected == nil {
//			continue
//		}
//		for _, a := range *v.Affected {
//			if a.Cpes != nil {
//				cpeKey := a.Cpes.String()
//				cpeMap[cpeKey] = *a.Cpes
//			}
//			if a.PlatformCpes != nil {
//				cpeKey := a.PlatformCpes.String()
//				cpeMap[cpeKey] = *a.PlatformCpes
//			}
//		}
//	}
//
//	// extract unique CPEs
//	var uniqueCPEs []*Cpes
//	for i := range cpeMap {
//		c := cpeMap[i]
//		uniqueCPEs = append(uniqueCPEs, &c)
//	}
//
//	// insert unique CPEs into the database or fetch existing ones
//	for i, c := range uniqueCPEs {
//		var existing Cpes
//		err := db.Where("type = ? AND vendor = ? AND product = ? AND edition = ? AND language = ? AND software_edition = ? AND target_software = ? AND target_hardware = ? AND other = ?", c.Type, c.Vendor, c.Product, c.Edition, c.Language, c.SoftwareEdition, c.TargetSoftware, c.TargetHardware, c.Other).
//			FirstOrCreate(&existing, c).Error
//		if err != nil {
//			return nil, err
//		}
//		uniqueCPEs[i] = &existing
//	}
//
//	return uniqueCPEs, nil
//}

//func (s *vulnerabilityStore) handleRangeEvents(vulns []*Vulnerability) error {
//	// ensure unique operating systems
//	unique, err := ensureUniqueRangeEvents(s.db, vulns)
//	if err != nil {
//		return err
//	}
//
//	// update vulnerabilities with operating system IDs
//	updateAffectedsWithRanges(vulns, unique)
//
//	return nil
//}
//
//func ensureUniqueRangeEvents(db *gorm.DB, vulns []*Vulnerability) ([]*RangeEvent, error) {
//	reMap := make(map[string]RangeEvent)
//	for _, v := range vulns {
//		for _, a := range *v.Affected {
//			if a.Range == nil {
//				continue
//			}
//			for _, r := range *a.Range {
//				if r.Events == nil {
//					continue
//				}
//				for _, re := range *r.Events {
//					reKey := fmt.Sprintf("%s:%s:%s:%s:%s", strVal(re.Introduced), strVal(re.Fixed), strVal(re.LastAffected), strVal(re.Limit), re.State)
//					reMap[reKey] = re
//				}
//			}
//		}
//	}
//
//	// extract unique range events
//	var uniqueRangeEvents []*RangeEvent
//	for i := range reMap {
//		re := reMap[i]
//		uniqueRangeEvents = append(uniqueRangeEvents, &re)
//	}
//
//	// insert unique range events into the database or fetch existing ones
//	for i, re := range uniqueRangeEvents {
//		var existing RangeEvent
//		err := db.Where("introduced = ? AND fixed = ? AND last_affected = ? AND range_limit = ? AND state = ?", re.Introduced, re.Fixed, re.LastAffected, re.Limit, re.State).
//			FirstOrCreate(&existing, re).Error
//		if err != nil {
//			return nil, err
//		}
//		uniqueRangeEvents[i] = &existing
//
//	}
//
//	return uniqueRangeEvents, nil
//}
//
//func updateAffectedsWithRanges(vulns []*Vulnerability, uniqueRangeEvents []*RangeEvent) {
//	reMap := make(map[string]int64)
//	for _, re := range uniqueRangeEvents {
//		reKey := fmt.Sprintf("%s:%s:%s:%s:%s", strVal(re.Introduced), strVal(re.Fixed), strVal(re.LastAffected), strVal(re.Limit), re.State)
//		reMap[reKey] = re.ID
//	}
//
//	for i, v := range vulns {
//		for j, a := range *v.Affected {
//			if a.Range == nil {
//				continue
//			}
//			for k, r := range *a.Range {
//				if r.Events == nil {
//					continue
//				}
//				for l, re := range *r.Events {
//					reKey := fmt.Sprintf("%s:%s:%s:%s:%s", strVal(re.Introduced), strVal(re.Fixed), strVal(re.LastAffected), strVal(re.Limit), re.State)
//					val := reMap[reKey]
//					(*(*(*vulns[i].Affected)[j].Range)[k].Events)[l].ID = val
//				}
//			}
//		}
//	}
//}
//
//func strVal(s *string) string {
//	if s == nil {
//		return ""
//	}
//	return *s
//}

//func (s *vulnerabilityStore) handleOSs(vulns []*Vulnerability) error {
//	// ensure unique operating systems
//	uniqueOSList, err := ensureUniqueOperatingSystems(s.db, vulns)
//	if err != nil {
//		return err
//	}
//
//	// update vulnerabilities with operating system IDs
//	updateAffectedsWithOperatingSystems(vulns, uniqueOSList)
//
//	return nil
//}
//
//func ensureUniqueOperatingSystems(db *gorm.DB, vulns []*Vulnerability) ([]*OperatingSystem, error) {
//	// map to track unique operating systems
//	osMap := make(map[string]*OperatingSystem)
//	for _, v := range vulns {
//		for _, a := range *v.Affected {
//			if a.OperatingSystem == nil {
//				continue
//			}
//			osKey := fmt.Sprintf("%s:%s:%s", a.OperatingSystem.Name, a.OperatingSystem.MajorVersion, a.OperatingSystem.MinorVersion)
//			osMap[osKey] = a.OperatingSystem
//		}
//	}
//
//	// extract unique operating systems
//	var uniqueOSList []*OperatingSystem
//	for _, os := range osMap {
//		uniqueOSList = append(uniqueOSList, os)
//	}
//
//	// insert unique operating systems into the database or fetch existing ones
//	for i, os := range uniqueOSList {
//		var existing OperatingSystem
//		err := db.Where("name = ? AND major_version = ? AND minor_version = ?", os.Name, os.MajorVersion, os.MinorVersion).
//			FirstOrCreate(&existing, os).Error
//		if err != nil {
//			return nil, err
//		}
//		uniqueOSList[i].ID = existing.ID
//	}
//
//	return uniqueOSList, nil
//}
//
//func updateAffectedsWithOperatingSystems(vulns []*Vulnerability, uniqueOSList []*OperatingSystem) {
//	osMap := make(map[string]int64)
//	for _, os := range uniqueOSList {
//		osKey := fmt.Sprintf("%s:%s:%s", os.Name, os.MajorVersion, os.MinorVersion)
//		osMap[osKey] = os.ID
//	}
//
//	for i, v := range vulns {
//		for j, a := range *v.Affected {
//			if a.OperatingSystem == nil {
//				continue
//			}
//			osKey := fmt.Sprintf("%s:%s:%s", a.OperatingSystem.Name, a.OperatingSystem.MajorVersion, a.OperatingSystem.MinorVersion)
//			val := osMap[osKey]
//			(*vulns[i].Affected)[j].OperatingSystemID = &val
//		}
//	}
//}
