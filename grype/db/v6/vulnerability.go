package v6

import (
	"fmt"
	"github.com/anchore/grype/internal/log"
	"gorm.io/gorm"
)

type VulnerabilityStore interface {
	AddVulnerabilities(vulns ...*Vulnerability) error
	GetVulnerability(vulnID string, includeAffectedPkgs bool) ([]Vulnerability, error)
}

type vulnerabilityStore struct {
	*StoreConfig
	*state
}

func NewVulnerabilityStore(cfg *StoreConfig) VulnerabilityStore {
	return &vulnerabilityStore{
		StoreConfig: cfg,
		state:       cfg.state(),
	}
}

func (s *vulnerabilityStore) GetVulnerability(id string, loadAuxInfo bool) ([]Vulnerability, error) {
	log.WithFields("name", id).Trace("fetching Vulnerability record")

	var models []Vulnerability

	db := s.db
	if loadAuxInfo {
		fields := s.getPreloadableFields(&Vulnerability{})
		for _, field := range fields {
			db = db.Preload(field)
		}
	}

	result := db.Where("name = ?", id).Find(&models)
	return models, result.Error
}

func (s *vulnerabilityStore) AddVulnerabilities(vulnerabilities ...*Vulnerability) error {
	// ensure unique operating systems
	uniqueOSList, err := ensureUniqueOperatingSystems(s.db, vulnerabilities)
	if err != nil {
		return err
	}

	// update vulnerabilities with operating system IDs
	updateVulnerabilitiesWithOperatingSystems(vulnerabilities, uniqueOSList)

	return s.db.CreateInBatches(vulnerabilities, 100).Error
}

func ensureUniqueOperatingSystems(db *gorm.DB, vulns []*Vulnerability) ([]*OperatingSystem, error) {
	// map to track unique operating systems
	osMap := make(map[string]*OperatingSystem)
	for _, v := range vulns {
		for _, a := range *v.Affected {
			if a.Package.OperatingSystem == nil {
				continue
			}
			osKey := fmt.Sprintf("%s:%s:%s", a.Package.OperatingSystem.Name, a.Package.OperatingSystem.MajorVersion, a.Package.OperatingSystem.MinorVersion)
			osMap[osKey] = a.Package.OperatingSystem
		}
	}

	// extract unique operating systems
	var uniqueOSList []*OperatingSystem
	for _, os := range osMap {
		uniqueOSList = append(uniqueOSList, os)
	}

	// insert unique operating systems into the database or fetch existing ones
	for i, os := range uniqueOSList {
		var existing OperatingSystem
		err := db.Where("name = ? AND major_version = ? AND minor_version = ?", os.Name, os.MajorVersion, os.MinorVersion).
			FirstOrCreate(&existing, os).Error
		if err != nil {
			return nil, err
		}
		uniqueOSList[i].ID = existing.ID
	}

	return uniqueOSList, nil
}

func updateVulnerabilitiesWithOperatingSystems(vulns []*Vulnerability, uniqueOSList []*OperatingSystem) {
	osMap := make(map[string]int64)
	for _, os := range uniqueOSList {
		osKey := fmt.Sprintf("%s:%s:%s", os.Name, os.MajorVersion, os.MinorVersion)
		osMap[osKey] = os.ID
	}

	for i, v := range vulns {
		for j, a := range *v.Affected {
			osKey := fmt.Sprintf("%s:%s:%s", a.Package.OperatingSystem.Name, a.Package.OperatingSystem.MajorVersion, a.Package.OperatingSystem.MinorVersion)
			val := osMap[osKey]
			(*vulns[i].Affected)[j].Package.OperatingSystemID = &val
		}
	}
}
