package v6

import (
	"fmt"
	"github.com/anchore/grype/internal/log"
	"gorm.io/gorm"
)

type VulnerabilityStore interface {
	AddVulnerabilities(vulns ...*Vulnerability) error
	GetVulnerability(vulnID string, includeAffectedPkgs bool) ([]Vulnerability, error)
}

type vulnerabilityStore struct {
	*StoreConfig
	*state
}

func NewVulnerabilityStore(cfg *StoreConfig) VulnerabilityStore {
	return &vulnerabilityStore{
		StoreConfig: cfg,
		state:       cfg.state(),
	}
}

func (s *vulnerabilityStore) GetVulnerability(id string, loadAuxInfo bool) ([]Vulnerability, error) {
	log.WithFields("name", id).Trace("fetching Vulnerability record")

	var models []Vulnerability

	db := s.db
	if loadAuxInfo {
		fields := s.getPreloadableFields(&Vulnerability{})
		for _, field := range fields {
			db = db.Preload(field)
		}
	}

	result := db.Where("name = ?", id).Find(&models)
	return models, result.Error
}

func (s *vulnerabilityStore) AddVulnerabilities(vulnerabilities ...*Vulnerability) error {
	for _, h := range []func([]*Vulnerability) error{
		s.handleOSs,
		s.handleRangeEvents,
		s.handleCPEs,
		s.handlePackages,
	} {
		if err := h(vulnerabilities); err != nil {
			return err
		}

	}

	return s.db.CreateInBatches(vulnerabilities, s.BatchSize).Error
}

func (s *vulnerabilityStore) handlePackages(vulns []*Vulnerability) error {
	// ensure unique packages
	unique, err := ensureUniquePackages(s.db, vulns)
	if err != nil {
		return err
	}

	// update vulnerabilities with package IDs
	updateAffectedsWithPackages(vulns, unique)

	return nil
}

func ensureUniquePackages(db *gorm.DB, vulns []*Vulnerability) ([]*Package, error) {
	// map to track unique packages
	pkgMap := make(map[string]*Package)
	for _, v := range vulns {
		for _, a := range *v.Affected {
			if a.Packages == nil {
				continue
			}
			pkgs := *a.Packages
			for i, p := range pkgs {
				pkgKey := fmt.Sprintf("%s:%s", strVal(p.Ecosystem), p.PackageName)
				val := &pkgs[i]
				pkgMap[pkgKey] = val
			}
		}
	}

	// extract unique packages
	var uniquePackages []*Package
	for _, pkg := range pkgMap {
		uniquePackages = append(uniquePackages, pkg)
	}

	// insert unique packages into the database or fetch existing ones
	for i, pkg := range uniquePackages {
		var existing Package
		err := db.Where("package_name = ? AND ecosystem = ?", pkg.PackageName, pkg.Ecosystem).
			FirstOrCreate(&existing, pkg).Error
		if err != nil {
			return nil, err
		}
		uniquePackages[i].ID = existing.ID
	}

	return uniquePackages, nil

}

func updateAffectedsWithPackages(vulns []*Vulnerability, uniquePackages []*Package) {
	pkgMap := make(map[string]int64)
	for _, p := range uniquePackages {
		pkgKey := fmt.Sprintf("%s:%s", strVal(p.Ecosystem), p.PackageName)
		pkgMap[pkgKey] = p.ID
	}

	for i, v := range vulns {
		for j, a := range *v.Affected {
			if a.Packages == nil {
				continue
			}
			pkgs := *a.Packages
			for k, p := range pkgs {
				pkgKey := fmt.Sprintf("%s:%s", strVal(p.Ecosystem), p.PackageName)
				val := pkgMap[pkgKey]
				(*(*vulns[i].Affected)[j].Packages)[k].ID = val
			}
		}
	}

}

func (s *vulnerabilityStore) handleCPEs(vulns []*Vulnerability) error {
	// ensure unique cpes
	unique, err := ensureUniqueCPEs(s.db, vulns)
	if err != nil {
		return err
	}

	// update vulnerabilities with cpes IDs
	updateAffectedsWithCPEs(vulns, unique)

	return nil
}

func updateAffectedsWithCPEs(vulns []*Vulnerability, uniqueCPEs []*Cpe) {
	cpeMap := make(map[string]int64)
	for _, c := range uniqueCPEs {
		cpeKey := fmt.Sprintf("%s:%s:%s:%s:%s:%s:%s", c.Schema, c.Type, strVal(c.Vendor), c.Product, strVal(c.Version), strVal(c.Update), strVal(c.TargetSoftware))
		cpeMap[cpeKey] = c.ID
	}

	for i, v := range vulns {
		if v.Affected == nil {
			continue
		}
		for j, a := range *v.Affected {
			if a.Cpes == nil {
				continue
			}
			for k, c := range *a.Cpes {
				cpeKey := fmt.Sprintf("%s:%s:%s:%s:%s:%s:%s", c.Schema, c.Type, strVal(c.Vendor), c.Product, strVal(c.Version), strVal(c.Update), strVal(c.TargetSoftware))
				val := cpeMap[cpeKey]
				(*(*vulns[i].Affected)[j].Cpes)[k].ID = val
			}
		}
	}
}

func ensureUniqueCPEs(db *gorm.DB, vulns []*Vulnerability) ([]*Cpe, error) {
	cpeMap := make(map[string]Cpe)
	for _, v := range vulns {
		if v.Affected == nil {
			continue
		}
		for _, a := range *v.Affected {
			if a.Cpes == nil {
				continue
			}
			for _, c := range *a.Cpes {
				cpeKey := fmt.Sprintf("%s:%s:%s:%s:%s:%s:%s", c.Schema, c.Type, strVal(c.Vendor), c.Product, strVal(c.Version), strVal(c.Update), strVal(c.TargetSoftware))
				cpeMap[cpeKey] = c
			}
		}
	}

	// extract unique CPEs
	var uniqueCPEs []*Cpe
	for i := range cpeMap {
		c := cpeMap[i]
		uniqueCPEs = append(uniqueCPEs, &c)
	}

	// insert unique CPEs into the database or fetch existing ones
	for i, c := range uniqueCPEs {
		var existing Cpe
		err := db.Where("schema = ? AND type = ? AND vendor = ? AND product = ? AND version = ? AND version_update = ? AND target_software = ?", c.Schema, c.Type, c.Vendor, c.Product, c.Version, c.Update, c.TargetSoftware).
			FirstOrCreate(&existing, c).Error
		if err != nil {
			return nil, err
		}
		uniqueCPEs[i] = &existing
	}

	return uniqueCPEs, nil
}

func (s *vulnerabilityStore) handleRangeEvents(vulns []*Vulnerability) error {
	// ensure unique operating systems
	unique, err := ensureUniqueRangeEvents(s.db, vulns)
	if err != nil {
		return err
	}

	// update vulnerabilities with operating system IDs
	updateAffectedsWithRanges(vulns, unique)

	return nil
}

func ensureUniqueRangeEvents(db *gorm.DB, vulns []*Vulnerability) ([]*RangeEvent, error) {
	reMap := make(map[string]RangeEvent)
	for _, v := range vulns {
		for _, a := range *v.Affected {
			if a.Range == nil {
				continue
			}
			for _, r := range *a.Range {
				if r.Events == nil {
					continue
				}
				for _, re := range *r.Events {
					reKey := fmt.Sprintf("%s:%s:%s:%s:%s", strVal(re.Introduced), strVal(re.Fixed), strVal(re.LastAffected), strVal(re.Limit), re.State)
					reMap[reKey] = re
				}
			}
		}
	}

	// extract unique range events
	var uniqueRangeEvents []*RangeEvent
	for i := range reMap {
		re := reMap[i]
		uniqueRangeEvents = append(uniqueRangeEvents, &re)
	}

	// insert unique range events into the database or fetch existing ones
	for i, re := range uniqueRangeEvents {
		var existing RangeEvent
		err := db.Where("introduced = ? AND fixed = ? AND last_affected = ? AND range_limit = ? AND state = ?", re.Introduced, re.Fixed, re.LastAffected, re.Limit, re.State).
			FirstOrCreate(&existing, re).Error
		if err != nil {
			return nil, err
		}
		uniqueRangeEvents[i] = &existing

	}

	return uniqueRangeEvents, nil
}

func updateAffectedsWithRanges(vulns []*Vulnerability, uniqueRangeEvents []*RangeEvent) {
	reMap := make(map[string]int64)
	for _, re := range uniqueRangeEvents {
		reKey := fmt.Sprintf("%s:%s:%s:%s:%s", strVal(re.Introduced), strVal(re.Fixed), strVal(re.LastAffected), strVal(re.Limit), re.State)
		reMap[reKey] = re.ID
	}

	for i, v := range vulns {
		for j, a := range *v.Affected {
			if a.Range == nil {
				continue
			}
			for k, r := range *a.Range {
				if r.Events == nil {
					continue
				}
				for l, re := range *r.Events {
					reKey := fmt.Sprintf("%s:%s:%s:%s:%s", strVal(re.Introduced), strVal(re.Fixed), strVal(re.LastAffected), strVal(re.Limit), re.State)
					val := reMap[reKey]
					(*(*(*vulns[i].Affected)[j].Range)[k].Events)[l].ID = val
				}
			}
		}
	}
}

func strVal(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func (s *vulnerabilityStore) handleOSs(vulns []*Vulnerability) error {
	// ensure unique operating systems
	uniqueOSList, err := ensureUniqueOperatingSystems(s.db, vulns)
	if err != nil {
		return err
	}

	// update vulnerabilities with operating system IDs
	updateAffectedsWithOperatingSystems(vulns, uniqueOSList)

	return nil
}

func ensureUniqueOperatingSystems(db *gorm.DB, vulns []*Vulnerability) ([]*OperatingSystem, error) {
	// map to track unique operating systems
	osMap := make(map[string]*OperatingSystem)
	for _, v := range vulns {
		for _, a := range *v.Affected {
			if a.OperatingSystem == nil {
				continue
			}
			osKey := fmt.Sprintf("%s:%s:%s", a.OperatingSystem.Name, a.OperatingSystem.MajorVersion, a.OperatingSystem.MinorVersion)
			osMap[osKey] = a.OperatingSystem
		}
	}

	// extract unique operating systems
	var uniqueOSList []*OperatingSystem
	for _, os := range osMap {
		uniqueOSList = append(uniqueOSList, os)
	}

	// insert unique operating systems into the database or fetch existing ones
	for i, os := range uniqueOSList {
		var existing OperatingSystem
		err := db.Where("name = ? AND major_version = ? AND minor_version = ?", os.Name, os.MajorVersion, os.MinorVersion).
			FirstOrCreate(&existing, os).Error
		if err != nil {
			return nil, err
		}
		uniqueOSList[i].ID = existing.ID
	}

	return uniqueOSList, nil
}

func updateAffectedsWithOperatingSystems(vulns []*Vulnerability, uniqueOSList []*OperatingSystem) {
	osMap := make(map[string]int64)
	for _, os := range uniqueOSList {
		osKey := fmt.Sprintf("%s:%s:%s", os.Name, os.MajorVersion, os.MinorVersion)
		osMap[osKey] = os.ID
	}

	for i, v := range vulns {
		for j, a := range *v.Affected {
			if a.OperatingSystem == nil {
				continue
			}
			osKey := fmt.Sprintf("%s:%s:%s", a.OperatingSystem.Name, a.OperatingSystem.MajorVersion, a.OperatingSystem.MinorVersion)
			val := osMap[osKey]
			(*vulns[i].Affected)[j].OperatingSystemID = &val
		}
	}
}
