package v6

import (
	"fmt"
	"github.com/anchore/grype/internal/log"
)

type VulnerabilityStoreWriter interface {
	AddVulnerabilities(vulns ...*VulnerabilityHandle) error
}

type VulnerabilityStoreReader interface {
	GetVulnerability(id int64) (*VulnerabilityHandle, error)
	GetVulnerabilitiesByName(vulnID string, includeAffectedPkgs bool) ([]VulnerabilityHandle, error)
}

type vulnerabilityStore struct {
	*StoreConfig
	*state
	blobStore *blobStore
}

func newVulnerabilityStore(cfg *StoreConfig, bs *blobStore) *vulnerabilityStore {
	return &vulnerabilityStore{
		StoreConfig: cfg,
		state:       cfg.state(),
		blobStore:   bs,
	}
}

func (s *vulnerabilityStore) GetVulnerability(id int64) (*VulnerabilityHandle, error) {
	log.WithFields("id", id).Trace("fetching Vulnerability record")

	var model VulnerabilityHandle

	//db := s.db
	//if loadAuxInfo {
	//	fields := s.getPreloadableFields(&VulnerabilityHandle{})
	//	for _, field := range fields {
	//		db = db.Preload(field)
	//	}
	//}

	result := s.db.Where("id = ?", id).First(&model)
	return &model, result.Error
}

func (s *vulnerabilityStore) GetVulnerabilitiesByName(name string) ([]VulnerabilityHandle, error) {
	log.WithFields("name", name).Trace("fetching Vulnerability record")

	var models []VulnerabilityHandle

	//db := s.db
	//if loadAuxInfo {
	//	fields := s.getPreloadableFields(&VulnerabilityHandle{})
	//	for _, field := range fields {
	//		db = db.Preload(field)
	//	}
	//}

	result := s.db.Where("name = ?", name).Find(&models)
	return models, result.Error
}

func (s *vulnerabilityStore) AddVulnerabilities(vulnerabilities ...*VulnerabilityHandle) error {
	for _, v := range vulnerabilities {
		if err := s.blobStore.AddVulnerabilityBlob(v); err != nil {
			return fmt.Errorf("unable to add affected blob: %w", err)
		}
		if err := s.db.Create(v).Error; err != nil {
			return err
		}

	}
	return nil
}
